// AUTOGENERATED FILE
// This file was generated from weaponAccessories.ohm by `ohm generateBundles`.

import {
  BaseActionDict,
  Grammar,
  IterationNode,
  Namespace,
  Node,
  NonterminalNode,
  Semantics,
  TerminalNode,
} from "ohm-js";

export interface AccuracyActionDict<T> extends BaseActionDict<T> {
  Exp?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  Accuracy?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  AddSub_add?: (
    this: NonterminalNode,
    arg0: NonterminalNode,
    arg1: TerminalNode,
    arg2: NonterminalNode
  ) => T;
  AddSub_subtract?: (
    this: NonterminalNode,
    arg0: NonterminalNode,
    arg1: TerminalNode,
    arg2: NonterminalNode
  ) => T;
  AddSub?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  MulDiv_multiply?: (
    this: NonterminalNode,
    arg0: NonterminalNode,
    arg1: TerminalNode,
    arg2: NonterminalNode
  ) => T;
  MulDiv_divide?: (
    this: NonterminalNode,
    arg0: NonterminalNode,
    arg1: TerminalNode,
    arg2: NonterminalNode
  ) => T;
  MulDiv?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  Physical?: (this: NonterminalNode, arg0: TerminalNode) => T;
  Missile?: (this: NonterminalNode, arg0: TerminalNode) => T;
  Number_negative?: (
    this: NonterminalNode,
    arg0: TerminalNode,
    arg1: NonterminalNode
  ) => T;
  Number?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  PositiveNumber_float?: (
    this: NonterminalNode,
    arg0: IterationNode,
    arg1: TerminalNode,
    arg2: IterationNode
  ) => T;
  PositiveNumber_int?: (this: NonterminalNode, arg0: IterationNode) => T;
  PositiveNumber?: (this: NonterminalNode, arg0: NonterminalNode) => T;
}

export interface AccuracySemantics extends Semantics {
  addOperation<T>(name: string, actionDict: AccuracyActionDict<T>): this;
  extendOperation<T>(name: string, actionDict: AccuracyActionDict<T>): this;
  addAttribute<T>(name: string, actionDict: AccuracyActionDict<T>): this;
  extendAttribute<T>(name: string, actionDict: AccuracyActionDict<T>): this;
}

export interface AccuracyGrammar extends Grammar {
  createSemantics(): AccuracySemantics;
  extendSemantics(superSemantics: AccuracySemantics): AccuracySemantics;
}

export interface DamageActionDict<T> extends BaseActionDict<T> {
  Exp_multipleDamage?: (
    this: NonterminalNode,
    arg0: NonterminalNode,
    arg1: TerminalNode,
    arg2: NonterminalNode
  ) => T;
  Exp_splitDamage?: (
    this: NonterminalNode,
    arg0: NonterminalNode,
    arg1: TerminalNode,
    arg2: NonterminalNode
  ) => T;
  Exp_special?: (
    this: NonterminalNode,
    arg0: NonterminalNode,
    arg1: TerminalNode,
    arg2: NonterminalNode,
    arg3: TerminalNode
  ) => T;
  Exp_base?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  Exp?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  Total_annotationRadius?: (
    this: NonterminalNode,
    arg0: NonterminalNode,
    arg1: NonterminalNode,
    arg2: NonterminalNode
  ) => T;
  Total_annotation?: (
    this: NonterminalNode,
    arg0: NonterminalNode,
    arg1: NonterminalNode
  ) => T;
  Total_radius?: (
    this: NonterminalNode,
    arg0: NonterminalNode,
    arg1: NonterminalNode
  ) => T;
  Total?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  Overall_typed?: (
    this: NonterminalNode,
    arg0: NonterminalNode,
    arg1: NonterminalNode
  ) => T;
  Overall_untyped?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  Overall?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  Radius?: (
    this: NonterminalNode,
    arg0: TerminalNode,
    arg1: NonterminalNode,
    arg2: TerminalNode
  ) => T;
  Range?: (
    this: NonterminalNode,
    arg0: TerminalNode,
    arg1: NonterminalNode,
    arg2: TerminalNode
  ) => T;
  Damage?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  AddSub_add?: (
    this: NonterminalNode,
    arg0: NonterminalNode,
    arg1: TerminalNode,
    arg2: NonterminalNode
  ) => T;
  AddSub_subtract?: (
    this: NonterminalNode,
    arg0: NonterminalNode,
    arg1: TerminalNode,
    arg2: NonterminalNode
  ) => T;
  AddSub_base?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  AddSub?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  MulDiv_multiply?: (
    this: NonterminalNode,
    arg0: NonterminalNode,
    arg1: TerminalNode,
    arg2: NonterminalNode
  ) => T;
  MulDiv_divide?: (
    this: NonterminalNode,
    arg0: NonterminalNode,
    arg1: TerminalNode,
    arg2: NonterminalNode
  ) => T;
  MulDiv?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  SubCalculation_parenthesis?: (
    this: NonterminalNode,
    arg0: TerminalNode,
    arg1: NonterminalNode,
    arg2: TerminalNode
  ) => T;
  SubCalculation_numberCalc?: (
    this: NonterminalNode,
    arg0: TerminalNode,
    arg1: NonterminalNode,
    arg2: TerminalNode,
    arg3: NonterminalNode,
    arg4: TerminalNode
  ) => T;
  SubCalculation?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  DamageValue?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  DrugToxin?: (this: NonterminalNode, arg0: TerminalNode) => T;
  Missile?: (this: NonterminalNode, arg0: TerminalNode) => T;
  PepperPunch?: (this: NonterminalNode, arg0: TerminalNode) => T;
  Strength?: (this: NonterminalNode, arg0: TerminalNode) => T;
  Magic?: (this: NonterminalNode, arg0: TerminalNode) => T;
  Chemical?: (this: NonterminalNode, arg0: TerminalNode) => T;
  Rating?: (this: NonterminalNode, arg0: TerminalNode) => T;
  Torpedo?: (this: NonterminalNode, arg0: TerminalNode) => T;
  Narcoject?: (this: NonterminalNode, arg0: TerminalNode) => T;
  Grenade?: (this: NonterminalNode, arg0: TerminalNode) => T;
  Special?: (this: NonterminalNode, arg0: TerminalNode) => T;
  Annotation_fire?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  Annotation_flechette?: (this: NonterminalNode, arg0: TerminalNode) => T;
  Annotation_electrical?: (this: NonterminalNode, arg0: TerminalNode) => T;
  Annotation?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  DamageType_physical?: (this: NonterminalNode, arg0: TerminalNode) => T;
  DamageType_stun?: (this: NonterminalNode, arg0: TerminalNode) => T;
  DamageType?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  Number_negative?: (
    this: NonterminalNode,
    arg0: TerminalNode,
    arg1: NonterminalNode
  ) => T;
  Number?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  PositiveNumber_float?: (
    this: NonterminalNode,
    arg0: IterationNode,
    arg1: TerminalNode,
    arg2: IterationNode
  ) => T;
  PositiveNumber_int?: (this: NonterminalNode, arg0: IterationNode) => T;
  PositiveNumber?: (this: NonterminalNode, arg0: NonterminalNode) => T;
}

export interface DamageSemantics extends Semantics {
  addOperation<T>(name: string, actionDict: DamageActionDict<T>): this;
  extendOperation<T>(name: string, actionDict: DamageActionDict<T>): this;
  addAttribute<T>(name: string, actionDict: DamageActionDict<T>): this;
  extendAttribute<T>(name: string, actionDict: DamageActionDict<T>): this;
}

export interface DamageGrammar extends Grammar {
  createSemantics(): DamageSemantics;
  extendSemantics(superSemantics: DamageSemantics): DamageSemantics;
}

export interface ArmourPenetrationActionDict<T> extends BaseActionDict<T> {
  Exp?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  Total_multiple?: (
    this: NonterminalNode,
    arg0: NonterminalNode,
    arg1: TerminalNode,
    arg2: NonterminalNode
  ) => T;
  Total_single?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  Total?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  ArmourPenetration?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  AddSub_add?: (
    this: NonterminalNode,
    arg0: NonterminalNode,
    arg1: TerminalNode,
    arg2: NonterminalNode
  ) => T;
  AddSub_subtract?: (
    this: NonterminalNode,
    arg0: NonterminalNode,
    arg1: TerminalNode,
    arg2: NonterminalNode
  ) => T;
  AddSub_base?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  AddSub?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  MulDiv_multiply?: (
    this: NonterminalNode,
    arg0: NonterminalNode,
    arg1: TerminalNode,
    arg2: NonterminalNode
  ) => T;
  MulDiv_divide?: (
    this: NonterminalNode,
    arg0: NonterminalNode,
    arg1: TerminalNode,
    arg2: NonterminalNode
  ) => T;
  MulDiv?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  NegativeAP_negative?: (
    this: NonterminalNode,
    arg0: TerminalNode,
    arg1: NonterminalNode
  ) => T;
  NegativeAP_base?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  NegativeAP?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  SubCalculation_parenthesis?: (
    this: NonterminalNode,
    arg0: TerminalNode,
    arg1: NonterminalNode,
    arg2: TerminalNode
  ) => T;
  SubCalculation?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  APValue?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  Grenade?: (this: NonterminalNode, arg0: TerminalNode) => T;
  Missile?: (this: NonterminalNode, arg0: TerminalNode) => T;
  Rating?: (this: NonterminalNode, arg0: TerminalNode) => T;
  Special?: (this: NonterminalNode, arg0: TerminalNode) => T;
  Magic?: (this: NonterminalNode, arg0: TerminalNode) => T;
  Nil?: (this: NonterminalNode, arg0: TerminalNode) => T;
  Number_negative?: (
    this: NonterminalNode,
    arg0: TerminalNode,
    arg1: NonterminalNode
  ) => T;
  Number?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  PositiveNumber_float?: (
    this: NonterminalNode,
    arg0: IterationNode,
    arg1: TerminalNode,
    arg2: IterationNode
  ) => T;
  PositiveNumber_int?: (this: NonterminalNode, arg0: IterationNode) => T;
  PositiveNumber?: (this: NonterminalNode, arg0: NonterminalNode) => T;
}

export interface ArmourPenetrationSemantics extends Semantics {
  addOperation<T>(
    name: string,
    actionDict: ArmourPenetrationActionDict<T>
  ): this;
  extendOperation<T>(
    name: string,
    actionDict: ArmourPenetrationActionDict<T>
  ): this;
  addAttribute<T>(
    name: string,
    actionDict: ArmourPenetrationActionDict<T>
  ): this;
  extendAttribute<T>(
    name: string,
    actionDict: ArmourPenetrationActionDict<T>
  ): this;
}

export interface ArmourPenetrationGrammar extends Grammar {
  createSemantics(): ArmourPenetrationSemantics;
  extendSemantics(
    superSemantics: ArmourPenetrationSemantics
  ): ArmourPenetrationSemantics;
}

export interface ModeActionDict<T> extends BaseActionDict<T> {
  Exp?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  Total_multiple?: (
    this: NonterminalNode,
    arg0: NonterminalNode,
    arg1: TerminalNode,
    arg2: NonterminalNode
  ) => T;
  Total_single?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  Total?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  Mode?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  BF?: (this: NonterminalNode, arg0: TerminalNode) => T;
  FA?: (this: NonterminalNode, arg0: TerminalNode) => T;
  SS?: (this: NonterminalNode, arg0: TerminalNode) => T;
  SA?: (this: NonterminalNode, arg0: TerminalNode) => T;
  Nil?: (this: NonterminalNode, arg0: TerminalNode) => T;
}

export interface ModeSemantics extends Semantics {
  addOperation<T>(name: string, actionDict: ModeActionDict<T>): this;
  extendOperation<T>(name: string, actionDict: ModeActionDict<T>): this;
  addAttribute<T>(name: string, actionDict: ModeActionDict<T>): this;
  extendAttribute<T>(name: string, actionDict: ModeActionDict<T>): this;
}

export interface ModeGrammar extends Grammar {
  createSemantics(): ModeSemantics;
  extendSemantics(superSemantics: ModeSemantics): ModeSemantics;
}

export interface AmmoActionDict<T> extends BaseActionDict<T> {
  Exp?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  Total_single?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  Total?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  Multiple?: (
    this: NonterminalNode,
    arg0: NonterminalNode,
    arg1: TerminalNode,
    arg2: NonterminalNode
  ) => T;
  Ammo_multipleBarrels?: (
    this: NonterminalNode,
    arg0: NonterminalNode,
    arg1: NonterminalNode,
    arg2: TerminalNode,
    arg3: NonterminalNode
  ) => T;
  Ammo_base?: (
    this: NonterminalNode,
    arg0: NonterminalNode,
    arg1: NonterminalNode
  ) => T;
  Ammo_multipleAmmoNeeded?: (
    this: NonterminalNode,
    arg0: NonterminalNode,
    arg1: TerminalNode,
    arg2: NonterminalNode,
    arg3: NonterminalNode
  ) => T;
  Ammo_noReload?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  Ammo_external?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  Ammo?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  ReloadMethod?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  Break?: (this: NonterminalNode, arg0: TerminalNode) => T;
  Clip?: (this: NonterminalNode, arg0: TerminalNode) => T;
  Drum?: (this: NonterminalNode, arg0: TerminalNode) => T;
  MuzzleLoader?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  InternalMagazine?: (this: NonterminalNode, arg0: TerminalNode) => T;
  Cylinder?: (this: NonterminalNode, arg0: TerminalNode) => T;
  BeltFed?: (this: NonterminalNode, arg0: TerminalNode) => T;
  Tank?: (this: NonterminalNode, arg0: TerminalNode) => T;
  External?: (this: NonterminalNode, arg0: TerminalNode) => T;
  Energy?: (this: NonterminalNode, arg0: TerminalNode) => T;
  CapAndBall?: (this: NonterminalNode, arg0: TerminalNode) => T;
  Number_negative?: (
    this: NonterminalNode,
    arg0: TerminalNode,
    arg1: NonterminalNode
  ) => T;
  Number?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  PositiveNumber_float?: (
    this: NonterminalNode,
    arg0: IterationNode,
    arg1: TerminalNode,
    arg2: IterationNode
  ) => T;
  PositiveNumber_int?: (this: NonterminalNode, arg0: IterationNode) => T;
  PositiveNumber?: (this: NonterminalNode, arg0: NonterminalNode) => T;
}

export interface AmmoSemantics extends Semantics {
  addOperation<T>(name: string, actionDict: AmmoActionDict<T>): this;
  extendOperation<T>(name: string, actionDict: AmmoActionDict<T>): this;
  addAttribute<T>(name: string, actionDict: AmmoActionDict<T>): this;
  extendAttribute<T>(name: string, actionDict: AmmoActionDict<T>): this;
}

export interface AmmoGrammar extends Grammar {
  createSemantics(): AmmoSemantics;
  extendSemantics(superSemantics: AmmoSemantics): AmmoSemantics;
}

export interface AvailabilityActionDict<T> extends BaseActionDict<T> {
  Exp_addition?: (
    this: NonterminalNode,
    arg0: TerminalNode,
    arg1: NonterminalNode
  ) => T;
  Exp?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  Availability_full?: (
    this: NonterminalNode,
    arg0: NonterminalNode,
    arg1: NonterminalNode
  ) => T;
  Availability_partial?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  Availability?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  AddSub_add?: (
    this: NonterminalNode,
    arg0: NonterminalNode,
    arg1: TerminalNode,
    arg2: NonterminalNode
  ) => T;
  AddSub_subtract?: (
    this: NonterminalNode,
    arg0: NonterminalNode,
    arg1: TerminalNode,
    arg2: NonterminalNode
  ) => T;
  AddSub_base?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  AddSub?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  MulDiv_multiply?: (
    this: NonterminalNode,
    arg0: NonterminalNode,
    arg1: TerminalNode,
    arg2: NonterminalNode
  ) => T;
  MulDiv_divide?: (
    this: NonterminalNode,
    arg0: NonterminalNode,
    arg1: TerminalNode,
    arg2: NonterminalNode
  ) => T;
  MulDiv?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  AvailabilityValue?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  Rating?: (this: NonterminalNode, arg0: TerminalNode) => T;
  Number_negative?: (
    this: NonterminalNode,
    arg0: TerminalNode,
    arg1: NonterminalNode
  ) => T;
  Number?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  PositiveNumber_float?: (
    this: NonterminalNode,
    arg0: IterationNode,
    arg1: TerminalNode,
    arg2: IterationNode
  ) => T;
  PositiveNumber_int?: (this: NonterminalNode, arg0: IterationNode) => T;
  PositiveNumber?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  Restriction?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  Restricted?: (this: NonterminalNode, arg0: TerminalNode) => T;
  Forbidden?: (this: NonterminalNode, arg0: TerminalNode) => T;
}

export interface AvailabilitySemantics extends Semantics {
  addOperation<T>(name: string, actionDict: AvailabilityActionDict<T>): this;
  extendOperation<T>(name: string, actionDict: AvailabilityActionDict<T>): this;
  addAttribute<T>(name: string, actionDict: AvailabilityActionDict<T>): this;
  extendAttribute<T>(name: string, actionDict: AvailabilityActionDict<T>): this;
}

export interface AvailabilityGrammar extends Grammar {
  createSemantics(): AvailabilitySemantics;
  extendSemantics(superSemantics: AvailabilitySemantics): AvailabilitySemantics;
}

export interface CostActionDict<T> extends BaseActionDict<T> {
  Exp?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  Cost?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  AddSub_add?: (
    this: NonterminalNode,
    arg0: NonterminalNode,
    arg1: TerminalNode,
    arg2: NonterminalNode
  ) => T;
  AddSub_subtract?: (
    this: NonterminalNode,
    arg0: NonterminalNode,
    arg1: TerminalNode,
    arg2: NonterminalNode
  ) => T;
  AddSub_base?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  AddSub?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  MulDiv_multiply?: (
    this: NonterminalNode,
    arg0: NonterminalNode,
    arg1: TerminalNode,
    arg2: NonterminalNode
  ) => T;
  MulDiv_divide?: (
    this: NonterminalNode,
    arg0: NonterminalNode,
    arg1: TerminalNode,
    arg2: NonterminalNode
  ) => T;
  MulDiv?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  CostValue?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  Rating?: (this: NonterminalNode, arg0: TerminalNode) => T;
  Weapon?: (this: NonterminalNode, arg0: TerminalNode) => T;
  Number_negative?: (
    this: NonterminalNode,
    arg0: TerminalNode,
    arg1: NonterminalNode
  ) => T;
  Number?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  PositiveNumber_float?: (
    this: NonterminalNode,
    arg0: IterationNode,
    arg1: TerminalNode,
    arg2: IterationNode
  ) => T;
  PositiveNumber_int?: (this: NonterminalNode, arg0: IterationNode) => T;
  PositiveNumber?: (this: NonterminalNode, arg0: NonterminalNode) => T;
}

export interface CostSemantics extends Semantics {
  addOperation<T>(name: string, actionDict: CostActionDict<T>): this;
  extendOperation<T>(name: string, actionDict: CostActionDict<T>): this;
  addAttribute<T>(name: string, actionDict: CostActionDict<T>): this;
  extendAttribute<T>(name: string, actionDict: CostActionDict<T>): this;
}

export interface CostGrammar extends Grammar {
  createSemantics(): CostSemantics;
  extendSemantics(superSemantics: CostSemantics): CostSemantics;
}

export interface ModifyAmmoCapacityActionDict<T> extends BaseActionDict<T> {
  Exp?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  FirstOperator_add?: (
    this: NonterminalNode,
    arg0: TerminalNode,
    arg1: NonterminalNode
  ) => T;
  FirstOperator_subtract?: (
    this: NonterminalNode,
    arg0: TerminalNode,
    arg1: NonterminalNode
  ) => T;
  FirstOperator_multiply?: (
    this: NonterminalNode,
    arg0: TerminalNode,
    arg1: NonterminalNode
  ) => T;
  FirstOperator_divide?: (
    this: NonterminalNode,
    arg0: TerminalNode,
    arg1: NonterminalNode
  ) => T;
  FirstOperator?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  ModifyAmmoCapacity?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  AddSub_add?: (
    this: NonterminalNode,
    arg0: NonterminalNode,
    arg1: TerminalNode,
    arg2: NonterminalNode
  ) => T;
  AddSub_subtract?: (
    this: NonterminalNode,
    arg0: NonterminalNode,
    arg1: TerminalNode,
    arg2: NonterminalNode
  ) => T;
  AddSub_base?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  AddSub?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  MulDiv_multiply?: (
    this: NonterminalNode,
    arg0: NonterminalNode,
    arg1: TerminalNode,
    arg2: NonterminalNode
  ) => T;
  MulDiv_divide?: (
    this: NonterminalNode,
    arg0: NonterminalNode,
    arg1: TerminalNode,
    arg2: NonterminalNode
  ) => T;
  MulDiv?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  SubCalculation_parenthesis?: (
    this: NonterminalNode,
    arg0: TerminalNode,
    arg1: NonterminalNode,
    arg2: TerminalNode
  ) => T;
  SubCalculation?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  ModifyValue?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  Weapon?: (this: NonterminalNode, arg0: TerminalNode) => T;
  Number_negative?: (
    this: NonterminalNode,
    arg0: TerminalNode,
    arg1: NonterminalNode
  ) => T;
  Number?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  PositiveNumber_float?: (
    this: NonterminalNode,
    arg0: IterationNode,
    arg1: TerminalNode,
    arg2: IterationNode
  ) => T;
  PositiveNumber_int?: (this: NonterminalNode, arg0: IterationNode) => T;
  PositiveNumber?: (this: NonterminalNode, arg0: NonterminalNode) => T;
}

export interface ModifyAmmoCapacitySemantics extends Semantics {
  addOperation<T>(
    name: string,
    actionDict: ModifyAmmoCapacityActionDict<T>
  ): this;
  extendOperation<T>(
    name: string,
    actionDict: ModifyAmmoCapacityActionDict<T>
  ): this;
  addAttribute<T>(
    name: string,
    actionDict: ModifyAmmoCapacityActionDict<T>
  ): this;
  extendAttribute<T>(
    name: string,
    actionDict: ModifyAmmoCapacityActionDict<T>
  ): this;
}

export interface ModifyAmmoCapacityGrammar extends Grammar {
  createSemantics(): ModifyAmmoCapacitySemantics;
  extendSemantics(
    superSemantics: ModifyAmmoCapacitySemantics
  ): ModifyAmmoCapacitySemantics;
}

declare const ns: {
  Accuracy: AccuracyGrammar;
  Damage: DamageGrammar;
  ArmourPenetration: ArmourPenetrationGrammar;
  Mode: ModeGrammar;
  Ammo: AmmoGrammar;
  Availability: AvailabilityGrammar;
  Cost: CostGrammar;
  ModifyAmmoCapacity: ModifyAmmoCapacityGrammar;
};
export default ns;
